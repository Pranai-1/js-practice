### ðŸ§± Your code:

const firstPromise = new Promise((res) => {
    res("First promise resolved");
});

const secondPromise = new Promise((res) => {
    res(firstPromise); // <- resolving with another promise
});

console.log(firstPromise, secondPromise);

### ðŸ§  Concept:

> When you resolve a promise **with another promise**, the outer promise **adopts the state** of the inner one.

#### âœ… `firstPromise`:
const firstPromise = new Promise((res) => {
    res("First promise resolved");
});


- Immediately resolves with `"First promise resolved"`
- So it's in the **fulfilled** state right away
- `console.log(firstPromise)` logs:  
  ðŸ‘‰ `Promise { 'First promise resolved' }`

#### â“ `secondPromise`:
const secondPromise = new Promise((res) => {
    res(firstPromise); // resolving with another promise!
});

- This **doesn't resolve immediately**
- Instead, it waits for `firstPromise` to **settle**
- Then it adopts the result of `firstPromise`

So at the time of the `console.log(...)`, itâ€™s **still pending**, just for a microtick.

Thatâ€™s why you get:

ðŸ‘‰ `Promise { <pending> }` for `secondPromise`

But if you log it **after a tick**, like:

setTimeout(() => {
    console.log("Later:", secondPromise);
}, 0);

Youâ€™ll see:
ðŸ‘‰ `Promise { 'First promise resolved' }`
